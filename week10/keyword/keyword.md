# Spring Security
## 1. 정의

---
- Spring 기반 애플리케이션의 인증과 인가 기능을 제공하는 강력한 보안 프레임워크
- 자바 웹 애플리케이션에서 사실상 표준으로 사용되며, 다양한 보안 위협(세션 고정, 클릭재킹, CSRF 등)으로부터 애플리케이션을 보호함

## 2. 주요 속성 및 특징

---
- 인증(Authentication): 사용자의 신원을 확인하는 과정. 아이디/비밀번호, 토큰 등 다양한 방식 지원
- 인가(Authorization): 인증된 사용자가 특정 리소스에 접근할 수 있는 권한이 있는지 확인
- 강력한 확장성: 커스텀 인증/인가 로직, 필터, 핸들러 등 다양한 확장이 가능함
- 다양한 보안 기능 내장
    - 세션 고정 공격, 클릭재킹, CSRF, XSS 등 주요 웹 공격 방지

      → **세션 고정 공격(Session Fixation):**

      공격자가 미리 발급받은 세션 ID를 피해자에게 강제로 사용하게 하여, 피해자가 로그인하면 해당 세션 ID로 인증이 완료된 상태가 되어 공격자가 피해자의 권한을 탈취하는 공격 방식

      → **클릭재킹(Clickjacking):**

      사용자가 의도하지 않은 버튼이나 링크를 클릭하도록 유도해, 실제로는 공격자가 숨겨놓은 악성 기능을 실행하게 만드는 공격.

      예를 들어, 투명한 프레임 위에 악성 버튼을 겹쳐 사용자가 클릭하게 만든다.

      → **CSRF(Cross-Site Request Forgery):**

      사용자가 인증된 상태에서 공격자가 의도한 요청을 사용자의 권한으로 서버에 보내게 하는 공격.

      예를 들어, 사용자가 모르게 계정 정보 변경, 결제 등 민감한 요청이 실행될 수 있다.

      → **XSS(Cross-Site Scripting):**

      웹사이트에 악성 스크립트를 삽입해, 사용자의 브라우저에서 해당 스크립트가 실행되도록 하는 공격.

      이를 통해 쿠키 탈취, 세션 하이재킹, 악성 코드 유포 등이 가능하다.

- Servlet 및 Spring Web MVC와 통합: 필터 체인 기반으로 모든 요청을 감시하고 보안을 적용함
- 다양한 인증 방식 지원: 폼 로그인, JWT, OAuth2 등
- 설정의 유연성: XML, 자바 어노테이션, 자바 Config 등 다양한 방식으로 설정 가능
- 테스트 용이성: MockMvc등과 연계해 인증/인가 테스트 지원

## 3. 핵심 구성요소

---
- **AuthenticationManager:** 인증 로직의 핵심, 다양한 인증 Provider를 위임·관리
- **AuthenticationProvider**: 실제 인증 처리 구현체
- **UserDetailsService**: 사용자 정보를 로딩하는 서비스
- **PasswordEncoder**: 비밀번호 암호화 및 검증 담당
- **GrantedAuthority/Role**: 사용자의 권한 및 역할 정보
- **SecurityContext/SecurityContextHolder**: 현재 인증된 사용자 정보를 저장·관리
- **Filter Chain**: 요청이 들어올 때 여러 보안 필터를 순차적으로 적용

# 인증(Authentication)과 인가(Authorization)
## 1. 정의

---
- **인증(Authentication)**

  사용자가 누구인지, 즉 신원을 확인하는 과정

  예를 들어, 로그인 시 아이디와 비밀번호, 지문, OTP 등으로 본인을 증명하는 절차


- **인가(Authorization)**

  인증된 사용자가 특정 리소스나 기능에 접근할 수 있는 권한이 있는지 확인하는 과정

  예를 들어, 로그인한 사용자가 관리자 페이지에 접근할 수 있는지, 파일을 읽거나 쓸 수 있는지 검사하는 절차


## 2. 주요 속성 및 차이점

---
| **구분** | **인증(Authentication)** | **인가(Authorization)** |
| --- | --- | --- |
| 목적 | 신원 확인 | 권한 부여/거부 |
| 질문 | “누구?” | "가능?" |
| 예시 | 로그인(아이디/비밀번호, 지문 등) | 관리자 권한, 파일 읽기/쓰기 권한 |
| 순서 | 먼저 수행 | 인증 후에 수행 |
| 사용자의 인지 가능 | 예 (직접 입력) | 보통 불가능 (시스템 내부 처리) |
| 데이터 | ID 토큰 등 | 액세스 토큰, 권한 정보 |

## 3. 실제 예시

---
- **은행 앱**
    - 인증: 로그인(아이디/비밀번호)
    - 인가: 계좌 조회, 이체, 관리자 기능 등 각 기능별 권한 확인
- **회사 내부 시스템**
    - 인증: 사번/비밀번호, 사원증 태깅
    - 인가: 부서별 파일 접근, 관리자/일반직원 권한 분리

# 세션과 토큰
## ✅ 세션 기반 인증

### 1. 정의 및 동작 원리

---
- 사용자가 로그인에 성공하면 서버는 고유한 세션 ID를 생성하고, 이를 클라이언트의 쿠키에 저장
- 서버는 세션 저장소에 인증 정보를 저장하고, 클라이언트는 요청마다 세션 ID를 쿠키에 담아 전송
- 서버는 세션 ID를 통해 사용자의 인증 상태를 확인하고, 세션 정보가 유효하면 요청을 처리함

### 2. 장점

---
- 보안성: 인증 정보가 서버에 저장되어 클라이언트 측 정보 유출 위험이 적음
- 즉각적 제어: 관리자가 세션을 강제로 만료시켜 로그아웃 처리 가능
- 사용자 경험: 로그인 후 여러 페이지를 이동해도 인증 상태가 유지됨

### 3. 단점

---
- 서버 부하: 모든 세션 정보를 서버가 관리하므로, 사용자가 많아질수록 서버 자원 소모가 커짐
- 확장성 한계: 여러 서버(분산 환경)에서 세션 동기화가 필요해 관리가 복잡함
- 세션 하이재킹 위험: 세션 ID가 탈취되면 보안 위협이 발생할 수 있음

## ✅ 토큰 기반 인증

### 1. 정의 및 동작 원리

---
- 사용자가 로그인에 성공하면 서버는 토큰을 발급해 클라이언트에게 전달함
- 클라이언트는 토큰을 로컬 스토리지, 쿠키 등에 저장하고, 이후 요청의 HTTP 헤더(Authorization)에 토큰을 포함시켜 전송함
- 서버는 토큰의 유효성(서명, 만료 등)을 검증해 인증 상태를 확인함

### 2. 장점

---
- 무상태(Stateless): 서버가 인증 정보를 저장하지 않아 서버 부하가 적고, 확장성이 뛰어남
- 분산 시스템에 유리: 여러 서버, 마이크로서비스 환경에서 인증 정보 공유가 쉬움
- 확장성: 다양한 서비스, 디바이스에서 동일 토큰으로 인증 가능
- 서명 및 무결성: JWT 등은 서명되어 위변조를 방지할 수 있음

### 3. 단점

---
- 보안 위험: 토큰이 탈취되면 만료 전까지 제어가 어렵고, 클라이언트 저장소 보안에 취약함
- 토큰 크기: JWT 등은 세션 ID보다 크기가 커 네트워크 오버헤드가 발생할 수 있음
- 만료 및 회수 어려움: 토큰 만료 전 강제 무효화가 어렵고, 별도의 갱신/회수 로직이 필요함
- Payload 노출: JWT의 Payload는 암호화되지 않아 누구나 내용을 볼 수 있으므로 민감 정보 저장에 주의해야 함

## 🤨 비교 요약

---
| **구분** | **세션** | **토큰** |
| --- | --- | --- |
| 인증 정보 저장 | 서버(세션 저장소) | 클라이언트(토큰 자체) |
| 서버 부하 | 사용자 수 증가 시 서버 자원 소모 증가 | 서버 부하 적음, 확장성 우수 |
| 확장성 | 분산 환경에서 세션 동기화 필요 | 분산 환경, 마이크로서비스에 적합 |
| 보안성 | 세션 ID 탈취 시 위험, 서버에서 즉시 만료 가능 | 토큰 탈취 시 만료 전까지 위험, 회수 어려움 |
| 만료/회수 | 서버에서 즉시 만료 가능 | 만료 전 강제 회수 어려움 |
| 네트워크 오버헤드 | 세션 ID만 전송(작음) | 토큰 크기가 커질 수 있음 |
| 사용 예시 | 전통적 웹 서비스, 내부 시스템 | REST API, 모바일, SPA, 마이크로서비스 등 |

# 액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)
## 1. 정의 및 역할

---
- **액세스 토큰(Access Token)**

  인증이 완료된 사용자가 API 등 보호된 리소스에 접근할 때 사용하는 토큰

  일반적으로 유효기간이 짧으며, 서버는 이 토큰만으로 사용자의 권한을 검증한다.

- **리프레시 토큰(Refresh Token)**

  액세스 토큰이 만료됐을 때, 새로운 액세스 토큰을 발급받기 위해 사용하는 토큰

  유효기간이 길고, 서버에서 별도로 저장·관리하여 보안성을 높인다.


## 2. 동작 원리

---
1. 사용자가 로그인하면 액세스 토큰과 리프레시 토큰이 함께 발급된다.
2. 클라이언트는 액세스 토큰을 HTTP 헤더(Authorization)에 담아 API 요청을 보낸다.
3. 액세스 토큰이 만료되면, 클라이언트는 리프레시 토큰을 이용해 새로운 액세스 토큰을 재발급받는다.
4. 리프레시 토큰까지 만료되면, 사용자는 다시 로그인해야 한다.

## 3. 장단점 비교

---
| **구분** | **액세스 토큰(Access Token)** | **리프레시 토큰(Refresh Token)** |
| --- | --- | --- |
| 역할 | 리소스 접근 인증 | 액세스 토큰 재발급 |
| 유효기간 | 짧음 (수분~수시간) | 김 (수일~수주) |
| 저장 위치 | 클라이언트(로컬, 쿠키 등) | 서버 및 클라이언트 |
| 탈취 시 위험 | 만료 전까지 무제한 사용 가능 | 서버에서 강제 만료 가능 |
| 보안 | 탈취 위험 높음, 유효기간 짧게 설정 필요 | 서버 저장, 만료·회수 가능 |
| 사용 빈도 | 모든 API 요청에 사용 | 액세스 토큰 만료 시에만 사용 |

## 4. 왜 두 가지 토큰을 쓰는가?

---
- **보안 강화**:

  액세스 토큰만 사용할 경우, 토큰이 탈취되면 만료 전까지 누구나 사용할 수 있어 위험하다.

  액세스 토큰의 유효기간을 짧게 하고, 리프레시 토큰으로 재발급하는 구조를 통해 보안성과 편의성을 모두 확보할 수 있다.


- **유저 경험 개선**:

  액세스 토큰이 자주 만료되어도, 리프레시 토큰이 유효하다면 사용자는 재로그인 없이 계속 서비스를 이용할 수 있다.
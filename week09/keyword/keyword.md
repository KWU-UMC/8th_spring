# 핵심 키워드
## Spring Data JPA의 Paging
paging을 사용하는 이유 : 한번에 많은 정보를 불러오기 힘들어서

### Page
정의: 전체 데이터의 총 개수와 현재 페이지의 데이터, 전체 페이지 수 등의 정보를 모두 포함하는 객체

일반적인 페이지네이션 기능이 필요하면 Page를 사용

적합한 상황

- UI에서 전체 페이지 수, 페이지 번호 이동을 제공해야 할 때 (ex. 1 2 3 4 … 버튼)
- 사용자가 원하는 페이지로 직접 점프할 수 있도록 만들고 싶을 때

동작구조

1. 실제 데이터 쿼리 (LIMIT/OFFSET)
2. 전체 개수를 구하기 위한 COUNT(*) 쿼리

주요 특징:

- getTotalElements() : 전체 데이터 개수
- getTotalPages() : 전체 페이지 수
- getNumber() : 현재 페이지 번호
- getSize() : 페이지당 데이터 수
- getContent() : 현재 페이지의 실제 데이터 리스트

장점: 페이지네이션 UI 구현에 유리 (총 페이지 수 등 제공)

단점: 전체 개수(count) 쿼리를 반드시 수행하기 때문에 성능이 저하될 수 있음 (특히 대용량 테이블에서)

주요 메서드

| **메서드** | **설명** |
| --- | --- |
| getContent() | 현재 페이지의 데이터 목록 (List<T>) |
| getTotalElements() | 전체 데이터 개수 |
| getTotalPages() | 총 페이지 수 (전체 개수 / 페이지 크기) |
| getNumber() | 현재 페이지 번호 |
| getSize() | 요청한 페이지 크기 |
| hasNext() | 다음 페이지가 있는지 |
| hasPrevious() | 이전 페이지가 있는지 |
| isFirst(), isLast() | 첫/마지막 페이지 여부 |

### Slice
정의: 현재 페이지에 해당하는 데이터와, 다음 페이지가 있는지 여부만 제공하는 객체

현재 페이지 데이터와 다음 페이지가 있는지 여부만 포함

count(*) 쿼리를 수행하지 않기 때문에 Page보다 가볍고 빠름

무한 스크롤 등에서 성능이 중요하면 Slice

적합한 상황

- 무한 스크롤 (스크롤 내릴 때마다 다음 페이지 불러오기)
- 전체 페이지 수가 필요하지 않은 경우
- 성능이 중요한 상황 (카운트 쿼리를 줄이기 위함)

동작 구조

1. PageSize + 1만큼 LIMIT으로 데이터를 조회함

2. 다음 페이지가 있는지(hasNext())를 확인함

주요 특징:

- hasNext() : 다음 페이지가 있는지 여부
- hasPrevious() : 이전 페이지가 있는지 여부
- getContent() : 현재 페이지의 실제 데이터 리스트
- getTotalPages()나 getTotalElements()는 제공하지 않음

장점: count 쿼리를 수행하지 않기 때문에 성능이 좋음

단점: 전체 페이지 수를 모름 → 페이지네이션 UI에는 부적합

주요 메서드

| **메서드** | **설명** |
| --- | --- |
| getContent() | 현재 페이지 데이터 목록 (List<T>) |
| hasNext() | 다음 페이지가 있는지 여부 |
| hasPrevious() | 이전 페이지가 있는지 여부 |
| getNumber() | 현재 페이지 번호 |
| getSize() | 페이지 크기 |
| isFirst(), isLast() | 첫/마지막 페이지 여부 |

! getTotalElements() / getTotalPages()는 없음

## 객체 그래프 탐색

  **JPA (Java Persistence API)를 통해 연관된 객체들을 참조를 따라 탐색하는 것을 의미**

  이는 객체 지향 모델링에서 객체 간의 관계를 효율적으로 관리하고 탐색하기 위한 방법

  **객체 그래프 탐색의 장점**

    - **데이터 접근의 효율성:**

      연관된 객체들을 한 번의 쿼리로 가져올 수 있어, 여러 쿼리를 수행하는 것보다 성능이 향상될 수 있으

    - **코드의 간결성:**

      객체 그래프 탐색을 통해 연관된 데이터를 쉽게 접근할 수 있으므로, 코드를 간결하게 유지할 수 있음

    - **데이터 일관성:**객체 그래프 탐색은 연관된 객체들을 일관성 있게 관리하므로, 데이터의 무결성을 유지할 수 있음

  **객체 그래프 탐색 방법:**

  **1. 연관 관계 설정:**JPA를 사용하여 객체 간의 연관 관계를 설정

  예를 들어, `member.setTeam(team)`과 같이 연관된 객체를 참조하는 방식으로 설정
  2**. 객체 그래프 탐색:**연관 관계를 통해 객체 그래프를 탐색

  예를 들어, `member.getTeam()`과 같이 연관된 객체를 참조하여 탐색
  3**. 지연 로딩 및 즉시 로딩:**객체 그래프 탐색 시, 연관된 객체를 필요할 때 (지연 로딩) 가져오거나, 미리 (즉시 로딩) 가져올 수 있음

  **객체 그래프 탐색의 주의점:**

    - **N+1 문제:**

      한 객체를 가져오기 위해 연관된 객체들을 각각 쿼리하는 경우, 성능이 저하될 수 있음

    - **무한 루프:**

      연관 관계가 잘못 설정되어 있다면 무한 루프가 발생할 수 있음

    - **데이터 일관성 유지:**객체 그래프 탐색을 통해 연관된 객체들을 변경하는 경우, 데이터 일관성을 유지해야함
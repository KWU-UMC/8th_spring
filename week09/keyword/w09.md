# 💡 Spring Data JPA의 Paging

데이터가 많을 때, 한 번에 다 불러오지 않고 **일정 단위로 나눠서 가져오는 기능**.

**→ 대용량 데이터를 효율적으로 조회하고, 클라이언트에 필요한 만큼만 제공할 수 있다.**

Spring Data JPA는 `Pageable` 객체를 통해 페이징 요청을 처리할 수 있도록 도와준다.


  ## 💡 Page

  `Page<T>`는 **전체 데이터 개수, 페이지 수, 현재 페이지 번호, 정렬 정보 등**을 포함한 페이징 결과 객체다.


  ### 주요 메서드

    - `getContent()` : 실제 데이터 목록 (`List<T>`)
    - `getTotalElements()` : 전체 데이터 개수
    - `getTotalPages()` : 전체 페이지 수
    - `getNumber()` : 현재 페이지 번호 (0부터 시작)
    - `hasNext()` / `hasPrevious()` : 다음/이전 페이지 존재 여부

  ### 예시

    ```java
    Page<Member> members = memberRepository.findAll(PageRequest.of(0, 10));
    ```

  → 0페이지부터 시작하며 한 페이지에 10개 데이터를 가져온다.

---
  ## 💡 Slice

  `Slice<T>`는 Page와 유사하지만, **전체 개수(total count)를 계산하지 않는다.**

  **→ 다음 페이지가 있는지만 알려주고, 전체가 몇 개인지는 모른다.**

  ### 특징

    - 성능 최적화에 유리 (count 쿼리 생략됨)
    - 무한 스크롤(Load more) 같은 기능에 적합
    - `hasNext()`로 다음 페이지 여부만 판단

  ### 예시

    ```java
    Slice<Member> members = memberRepository.findByName("희지", PageRequest.of(0, 10));
    ```

  → 0페이지부터 이름이 ‘희지’인 회원 10명까지 가져오고, 다음 페이지 존재 여부만 확인한다.


## page와 slice 비교

| 항목 | Page | Slice |
| --- | --- | --- |
| 전체 개수 조회 | O (`count`) | X |
| 다음 페이지 여부 | O | O |
| 용도 | 페이지 수를 보여주는 목록 | 무한스크롤 |
| 장점 | 정밀한 페이징 | 성능 좋음 |

→ 일반 게시판: `Page`,

→ 무한 스크롤이나 리스트 더 보기: `Slice` 사용 권장

---

## 💡 객체 그래프 탐색

JPA에서 연관된 객체를 탐색하는 방식.

즉, 엔티티를 조회한 후에, **연관된 엔티티에 접근하는 것**을 말한다.

**→ JPA는 이를 통해 객체들 간의 연관관계를 그대로 유지하며 동작한다.**


### 기본 개념

```java
Member member = em.find(Member.class, 1L);
String city = member.getAddress().getCity();
```

→ `member`에서 `address`로, 또 그 안의 `city`까지 탐색하는 것.

→ 마치 객체지향의 객체 그래프처럼 `.`으로 연결해서 접근 가능

---

### 주의할 점: **지연로딩 vs 즉시로딩**

- `@OneToMany(fetch = FetchType.LAZY)` : 실제 접근할 때 쿼리 실행됨
- `@ManyToOne(fetch = FetchType.EAGER)` : 바로 조회할 때 join해서 같이 가져옴

→ 연관 객체가 많거나 복잡할수록 **N+1 문제**가 발생할 수 있음

---

### 성능 문제 예시: N + 1

    ```java
    List<Member> members = em.createQuery("select m from Member m").getResultList();
    for (Member member : members) {
        System.out.println(member.getTeam().getName()); // 여기서 매번 쿼리 발생
    }
    ```

→ 위 코드는 Member를 10명 가져오면, Team 쿼리가 10번 더 실행됨

→ 총 1 + 10 = 11번 쿼리 ⇒ **N+1 문제**

---

### 해결 방법

- **Fetch Join 사용**

    ```
    select m from Member m join fetch m.team
    ```

- **@EntityGraph 사용**

    ```java
    @EntityGraph(attributePaths = {"team"})
    List<Member> findAll();
    ```

- **쿼리 튜닝**과 **지연로딩 전략 수정**
# 핵심 키워드

## Domain
### 의미
    Entity: 바구니 같은 역할. 실제 데이터 관계가 어떻게 되어 있다 하고 보여주는. 데이터 베이스의 원천은 따로 있음. 이걸 객체로서 가져와야 하는데 그때 상황에 맞게 바꿔서 가져오는 것.
    
    소프트웨어에서 **문제 해결 대상이 되는 영역. 비니지스 규칙**이나 **핵심 개념을 표현하**는 영역.
    비즈니스 로직이 이 영역에 속하고, 핵심 데이터와 그 데이터에 대한 규칙을 담고 있음.
    기획의 요구 사항을 구현하고, 문제를 풀기 위해 설계된 소프트웨어 프로그램의 기능성을 정의하는 영역.

    = 사용자가 이용하는 앱의 기능, 회사의 비즈니스 로직을 정의하고 있는 영역  

### 프로그래밍에서의 Domain
    주로  Entity 클래스나 Value Object(VO) 클래스 형태로 구현됨.
    (ex. 쇼핑몰에서 회원, 주문, 상품 같은 것들이 도메인 모델)

## 양방향 매핑
### 의미
    소프트웨어에서 **문제 해결 대상이 되는 영역. 비니지스 규칙**이나 **핵심 개념을 표현하**는 영역.
    비즈니스 로직이 이 영역에 속하고, 핵심 데이터와 그 데이터에 대한 규칙을 담고 있음.
    기획의 요구 사항을 구현하고, 문제를 풀기 위해 설계된 소프트웨어 프로그램의 기능성을 정의하는 영역.

    = 사용자가 이용하는 앱의 기능, 회사의 비즈니스 로직을 정의하고 있는 영역

### 구성 요소
    - **주인(owner)**: 외래 키(FK)를 관리하는 쪽.
    - **비주인(mappedBy)**: 주인이 관리하는 외래 키를 읽기만 하는 쪽.

### 주의할 점
    **연관 관계의 주인**을 정확히 정해야 한다. (외래키를 관리하는 쪽)
    **무한 루프**를 방지하는 설정이 필요함.

    비즈니스 로직에서 양쪽 객체를 자유롭게 탐색할 수 있어야 함. (ex. "회원"에서 "주문"을 조회할 수도 있고, "주문"에서 "회원"을 조회할 수도 있어야 함.)

    Many to one : 필수. (외래키 관련해서) / one to many 관계는 필수 X.

## N+1 문제
### 의미
    1개의 쿼리를 보낸 후(N), 연관된 엔티티들을 가져오기 위해 추가로 1개의 쿼리를 각 엔티티마다 보내는 문제. 데이터 조회 시 **한 번의 조회(N)** 이후, 관련된 데이터를 각각 **추가 조회(+1)** 하면서 발생하는 성능 문제. (ex. 리스트로 엔티티를 가져왔는데, 각 엔티티에 연관된 데이터를 또 DB에서 매번 조회하는 상황.)

### 발생 원인
    관계형 데이터베이스와 객체지향 언어간의 패러다임 차이로 인해 발생.
    객체는 연관관계를 통해 레퍼런스를 가지고 있으면 언제든지 메모리 내에서 **Random Access**를 통해 연관 객체에 접근할 수 있지만 RDB의 경우 **Select 쿼리**를 통해서만 조회할 수 있기 때문. JPA 기본 설정이 `LAZY` 로딩이기 때문.
    = 그래서 부모(예: Member)만 먼저 가져오고, 그 다음에 각 Member에 연결된 Orders를 **하나하나** 추가 조회하는 것임.

### N+1이 문제가 되는 이유
    N+1문제가 발생하면 쿼리가 배수적으로 증가하면서 DB에 큰 부담이 발생하게 되고 장애 요인이 될 수 있음. 또한 사용자 관점에서 지연율 또한 크게 증가할 수 있기 때문.
# 6주차 키워드

## 1. 즉시로딩과 지연로딩의 차이
- 즉시로딩은 데이터를 조회할 때 연관된 데이터까지 한 번에 불러오는 것
- 지연로딩은 필요한 시점에 필요한 데이터를 불러오는 것
- 연관된 데이터가 많다면 즉시로딩을 사용할 경우 JPQL에서 N+1 문제가 발생할 수 있기 때문에, 가급적이면 지연로딩을 사용하는 것이 좋음


### 즉시로딩(EAGER)
- 데이터를 조회할 때, 연관된 모든 객체의 데이터까지 한 번에 불러오는 것
- xxToxx(fetchType.EAGER)

### 지연로딩(LAZY)
- 필요한 시점에 연관된 객체의 데이터를 불러오는 것
- xxToxx(fetchType.LAZY)

## 2. Fetch Join
#### Join
- 실제 쿼리에서 select하는 entity는 오직 JPQL에서 조회하는 주체가 되는 entity만 조회하여 영속화함
- 조회의 주체가 되는 엔티티만 select해서 영속화 -> 데이터는 필요하지 않지만, 연관 엔티티가 검색조건에는 필요한 경우에 주로 사용

#### Fetch Join
- 조회의 주체가 되는 엔티티 이외에 Fetch Join이 걸린 연관 엔티티도 함께 select하여 모두 영속화
- FetchType이 Lazy인 엔티티를 참조하더라도 이미 영속성 컨텍스트에 들어가있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1 문제 해결


## 3. @EntityGraph
- JPA가 제공하는 엔티티 그래프 기능을 편리하게 사용하도록 도와줌
- JPQL로 @EntityGraph 어노테이션을 붙임으로서 fetch join을 직접 작성하지 않고 편리하게 사용 가능
- fetch join을 적용해주기 때문에 N+1문제를 해결하고, 성능 최적화에 도움
- left outer join만을 지원하기 때문에 다른 방식이 필요하면 직접 fetch join을 사용해야 함


## 4. JPQL
- 엔티티 객체를 대상으로 하는 쿼리 언어
- 엔티티 클래스 이름, 엔티티 필드의 대소문자가 일치해야 함
- JPQL 키워드는 대소문자를 구분하지 않음
- 엔티티 객체를 대상으로 하는 쿼리이므로 테이블 이름이 아닌 엔티티 이름을 사용
- SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN을 지원함
- SQL과 문법이 유사하지만 JPQL은 엔티티 객체를 대상으로 쿼리문을 작성, SQL은 데이터 베이스 테이블을 대상으로 쿼리문을 작성하는 것
- 문제점: String 형태이므로 개발자 의존적 형태 / Compile 단계에서 Type-check 불가능

## 5. QueryDSL
- JPQL을 보완하기 위해 나왔으며, 정적 타입을 이용해 SQL, JPQL을 코드로 작성할 수 있도록 도와주는 오픈소스 빌더 API
- 쿼리에 대한 내용을 함수 형태로 제공하여 String 형태인 JPQL을 보완
- 장점: 문자가 아닌 코드로 작성 / Compile 단계에서 문법 오류 확인 가능 / 동적 쿼리 구현 가능
- 단점: 코드 길이가 늘어남


## 6. N+1 문제를 해결할 수 있는 방법
- 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는 연관관계도 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제
- OOP는 Random Access를 통해 바로 메모리에 접근 가능하지만, RDB는 SELECT 쿼리를 통해서만 데이터 접근이 가능하기에 발생
- fetch join + 지연로딩 사용 / @EntityGraph 사용으로 해결
- @BatchSize를 통해서도 해결할 수 있지만, Fetch Join보다는 몇 번의 쿼리가 더 발생할 수는 있음

## + OOP, RDB, ORM 정리
- OOP: 코드 작성 방식 / RDB: 데이터 저장 방식 / ORM: OOP와 RDB사이 연결 도구
- RDB는 데이터를 테이블로 저장, SQL 언어를 사용함
- ORM(Object-Relational Mapping)은 OOP코드와 RDB테이블 간 연결 다리

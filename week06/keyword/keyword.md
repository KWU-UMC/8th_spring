### 지연로딩과 즉시로딩의 차이
지연 로딩(Lazy Loading)은 엔티티를 조회할 때 연관된 객체를 즉시 로딩하지 않고, 실제로 접근하는 시점에 쿼리를 실행한다.
즉시 로딩(Eager Loading)은 엔티티를 조회할 때 연관된 객체도 함께 즉시 조회하여 가져온다.
지연 로딩은 불필요한 쿼리 실행을 줄일 수 있지만, 연관 객체를 반복 접근하면 N+1 문제가 발생할 수 있다.
즉시 로딩은 필요한 데이터를 한 번에 가져오지만, 불필요한 데이터까지 조회해 성능 저하를 유발할 수 있다.
기본 설정은 대부분 지연 로딩이며, fetch = FetchType.LAZY 또는 EAGER로 명시할 수 있다.

### Fetch Join
Fetch Join은 연관된 엔티티를 지연 로딩 설정과 무관하게 즉시 로딩하기 위해 사용하는 JPQL의 조인 방식이다.
보통 select m from Member m join fetch m.team처럼 사용되며, 두 테이블을 한 번의 SQL로 함께 조회한다.
이 방식은 N+1 문제를 해결하는 데 효과적이며, 연관 객체를 미리 로딩해야 할 때 유용하다.
단, 컬렉션(fetch join 다대일 또는 일대다 관계)을 조인하면 페이징이 불가능해 성능 문제가 발생할 수 있다.
따라서 필요한 경우에만 신중하게 사용해야 하며, QueryDSL에서도 fetchJoin()으로 쉽게 활용 가능하다.

### @EntityGraph
@EntityGraph는 JPA에서 지연 로딩으로 설정된 연관 엔티티를 JPQL 없이 즉시 로딩하도록 도와주는 어노테이션이다.
기존의 fetch join을 대체할 수 있으며, 메서드 수준에서 간결하게 로딩 전략을 지정할 수 있다는 장점이 있다.
예를 들어, @EntityGraph(attributePaths = {"team"})처럼 사용하면 team 연관 엔티티를 함께 조회한다.
Spring Data JPA의 findById 같은 메서드에도 적용 가능하며, N+1 문제 해결에 효과적이다.
단, 너무 많은 경로를 지정하면 복잡한 SQL이 생성되므로 필요한 경로만 선택적으로 사용하는 것이 좋다.

### JPQL
JPQL(Java Persistence Query Language)은 JPA에서 사용하는 객체 지향 쿼리 언어로, SQL과 유사하지만 테이블이 아닌 엔티티를 기준으로 쿼리를 작성한다.
연관 관계를 통한 조인, 서브쿼리, 집계 함수 등도 지원하지만, 일부 DB 고유 기능은 사용할 수 없다.
타입 안전성은 보장되지 않기 때문에 컴파일 타임 오류를 잡기 어렵고, 복잡한 동적 쿼리에 적합하지 않다.
이런 한계를 보완하기 위해 QueryDSL과 같은 대안이 자주 사용된다.

### QueryDSL

QueryDSL은 자바 코드로 SQL과 유사한 쿼리를 타입 안전하게 작성할 수 있는 DSL(Domain Specific Language)이다.
JPA와 함께 사용하면 컴파일 시점에 문법 오류를 잡을 수 있고, IDE 자동완성도 지원되어 복잡한 동적 쿼리를 쉽게 작성할 수 있다.
JPQL보다 가독성과 유지보수성이 높고, N+1 문제 해결을 위한 fetchJoin, 서브쿼리 등도 유연하게 구현할 수 있다.
단점으로는 초기 설정이 다소 복잡하며, 쿼리 타입(Q 클래스) 생성을 위한 추가 빌드 설정이 필요하다
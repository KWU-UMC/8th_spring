### **서블릿 vs. Spring MVC 비교**

**💡 미션:**

- **전통적인 서블릿(Servlet) 기반 개발과 Spring MVC의 차이:
서블릿 기반 개발
서블릿은 자바 클래스 형태로 작성되며, 클라이언트의 요청을 처리하고 응답을 생성하는 기본적인 웹 기술입니다.

특징
직접적인 요청/응답 처리: HttpServletRequest와 HttpServletResponse 객체를 사용해 요청 데이터를 읽고 응답을 작성해야 합니다.

URL마다 서블릿 필요: 각 URL에 대해 별도의 서블릿 클래스를 작성해야 하며, 이를 web.xml에 매핑해야 합니다.

복잡한 작업 처리: JSON 데이터 처리, 파라미터 매핑 등 모든 작업을 개발자가 직접 구현해야 합니다.

낮은 추상화 수준: 비즈니스 로직과 뷰 로직의 분리가 어렵고 코드 중복이 발생하기 쉽습니다.

장점
경량이며, 단순한 구조로 시작하기 용이합니다.

자바의 기본 기능을 그대로 활용할 수 있습니다.

단점
유지보수와 확장이 어렵습니다.

반복적인 코드가 많아 생산성이 낮습니다.

Spring MVC
Spring MVC는 서블릿 위에 구축된 프레임워크로, MVC(Model-View-Controller) 패턴을 적용해 웹 애플리케이션 개발을 효율적으로 만듭니다.

특징
DispatcherServlet 사용: 모든 요청은 DispatcherServlet이라는 프론트 컨트롤러가 받아 적절한 컨트롤러로 전달합니다. 이를 통해 URL마다 서블릿을 생성할 필요가 없습니다.

자동화된 작업 처리: JSON 변환, 요청 파라미터 매핑 등 많은 작업이 자동화되어 있습니다. 예를 들어, @RequestBody와 같은 어노테이션으로 JSON 데이터를 객체로 쉽게 변환할 수 있습니다.

유연한 뷰 관리: JSP, Thymeleaf 등 다양한 뷰 기술과 통합 가능합니다.

강력한 통합 기능: Spring의 DI(Dependency Injection), AOP(Aspect-Oriented Programming) 등의 기능을 활용해 비즈니스 로직과 데이터 접근 계층을 쉽게 관리할 수 있습니다.

장점
유지보수성과 확장성이 뛰어납니다.

코드 중복이 줄어들고 생산성이 높아집니다.

다양한 Spring 생태계(보안, 데이터 접근 등)와 통합이 용이합니다.

단점
초기 설정과 학습 곡선이 상대적으로 높습니다.

경량 프로젝트에는 과도할 수 있습니다.

비교
항목	서블릿 기반 개발	Spring MVC
구조	단순하지만 반복적인 코드 많음	MVC 패턴으로 역할 분리 명확
요청 처리 방식	URL마다 서블릿 작성 필요	DispatcherServlet이 모든 요청 관리
데이터 변환	직접 JSON 파싱 및 객체 매핑	자동화된 데이터 변환 (e.g., @RequestBody)
유지보수성	낮음	높음
생산성	낮음	높음
확장성 및 통합성	제한적	Spring 생태계와 강력한 통합
결론적으로, 서블릿은 기본적인 웹 애플리케이션 개발에 적합하지만, 복잡한 애플리케이션에서는 생산성과 유지보수성이 떨어집니다. 반면 Spring MVC는 서블릿의 복잡성을 감추고 개발자가 비즈니스 로직에 집중할 수 있도록 도와주는 고급 프레임워크입니다.
   


- AOP가 무엇인지, 그리고 왜 필요한지 개념적으로 정리한 내용을 블로그 내용에 정의하기
   AOP란 무엇인가?
**AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)**는 소프트웨어 개발 패러다임으로, 프로그램의 핵심 비즈니스 로직과 부가적인 공통 기능(예: 로깅, 보안, 트랜잭션 관리 등)을 분리하여 관리하는 방법입니다. 이를 통해 코드 중복을 줄이고 유지보수를 용이하게 합니다.

AOP의 주요 개념
Aspect: 공통 기능(횡단 관심사)을 캡슐화한 모듈.

Join Point: Aspect가 적용될 수 있는 구체적인 실행 지점(예: 메서드 호출 전후).

Advice: Join Point에서 실행될 코드(예: 메서드 실행 전후 로깅).

Pointcut: 특정 Join Point를 지정하는 표현식.

Weaving: Aspect를 핵심 로직에 적용하는 과정.

AOP가 필요한 이유
횡단 관심사 관리: 로깅, 보안, 트랜잭션 관리 등 여러 모듈에서 반복적으로 사용되는 기능을 한 곳에서 관리.

코드 간결화: 핵심 비즈니스 로직과 부가 기능을 분리하여 코드의 가독성과 유지보수성을 향상.

중복 제거 및 재사용성 증가: 공통 기능을 모듈화하여 재사용 가능.

OOP와 AOP의 차이
특징	OOP (객체 지향 프로그래밍)	AOP (관점 지향 프로그래밍)
초점	객체 중심으로 데이터와 메서드를 캡슐화	횡단 관심사(공통 기능)를 모듈화
목적	클래스와 객체를 통해 비즈니스 로직을 구조화	핵심 로직과 공통 기능의 분리
처리 방식	상속, 다형성 등을 통해 코드 재사용	특정 시점(Join Point)에 공통 기능 자동 적용
문제 해결 방식	객체 간 관계를 정의하고 모듈화를 통해 문제 해결	OOP로 해결하기 어려운 횡단 관심사를 효과적으로 처리
코드 중복 문제	반복적으로 필요한 공통 기능은 각 클래스에 구현해야 함	공통 기능을 한 곳에서 정의하고 필요 시 자동으로 적용
유지보수성	비즈니스 로직과 부가 기능이 섞여 있어 수정 시 복잡도가 증가	핵심 로직과 부가 기능이 분리되어 유지보수가 용이
관계
AOP는 OOP를 대체하지 않고 보완합니다. OOP는 시스템의 구조를 설계하는 데 유용하며, AOP는 그 구조 내에서 공통 기능을 효율적으로 처리하여 코드 품질과 유지보수성을 향상시킵니다.

결론
OOP는 객체 중심으로 프로그램을 설계하는 데 적합하며, AOP는 OOP로 처리하기 어려운 횡단 관심사를 효과적으로 관리합니다. 두 패러다임은 상호 보완적이며 함께 사용하면 더 유연하고 효율적인 소프트웨어 개발이 가능합니다


- Spring에서 AOP가 프록시 패턴(Proxy Pattern)을 활용하여 동작하는 원리 분석.
Spring AOP는 프록시 패턴을 기반으로 동작하며, 핵심 비즈니스 로직과 횡단 관심사(Cross-Cutting Concerns)를 분리하여 관리합니다. 이를 위해 JDK 동적 프록시 또는 CGLIB를 사용해 대상 객체(Target Object)를 감싸는 프록시를 생성하고, 메서드 호출을 가로챈 후 부가 기능(Advice)을 적용합니다.

프록시 생성 메커니즘
프록시 타입 결정:

JDK 동적 프록시: 대상 객체가 인터페이스를 구현한 경우 사용됩니다. 인터페이스 기반으로 프록시를 생성하며, java.lang.reflect.Proxy 클래스를 활용합니다.

CGLIB: 인터페이스가 없는 클래스의 경우, 대상 클래스를 상속받는 서브클래스 프록시를 생성합니다. final 클래스/메서드는 프록시 생성이 불가능합니다.

프록시 생성 시기:

애플리케이션 컨텍스트 초기화 단계에서 BeanPostProcessor(예: AnnotationAwareAspectJAutoProxyCreator)가 @Aspect, @Transactional 등 AOP 관련 어노테이션이 있는 빈을 검출해 프록시를 생성합니다.

AOP 동작 원리
메서드 호출 가로채기(Intercept):

클라이언트가 빈의 메서드를 호출하면 프록시 객체가 먼저 요청을 받습니다.

프록시는 Pointcut을 통해 해당 메서드가 Advice 적용 대상인지 판단합니다.

Advice 실행:

Before Advice: 대상 메서드 실행 전에 로직 적용(예: 로깅).

After Advice: 대상 메서드 실행 후 로직 적용(예: 트랜잭션 커밋).

Around Advice: 대상 메서드 실행 전후에 로직을 감싸며, ProceedingJoinPoint.proceed()로 원본 메서드 호출을 제어합니다.

대상 메서드 실행:

Advice 적용 후 프록시는 대상 객체의 실제 메서드를 호출합니다. 이때 프록시는 원본 객체를 참조합니다.

핵심 구성 요소
구성 요소	역할
Aspect	횡단 관심사를 모듈화한 클래스(예: @Aspect 어노테이션 사용).
Advisor	Pointcut과 Advice를 조합한 객체(예: DefaultPointcutAdvisor).
Weaving	프록시 생성 및 Advice를 대상 객체에 적용하는 과정(런타임 시 수행).
예시: 프록시 동작 흐름
java
// 1. 대상 객체
public class UserService {
    public void createUser() { /* 비즈니스 로직 */ }
}

// 2. Aspect 정의
@Aspect
public class LoggingAspect {
    @Before("execution(* UserService.createUser())")
    public void logBefore() { System.out.println("로그 기록"); }
}

// 3. 클라이언트 호출 시
UserService proxy = // Spring이 생성한 프록시
proxy.createUser(); // 프록시가 로깅 후 실제 createUser() 호출
프록시의 투명성
클라이언트는 프록시의 존재를 인지하지 못하며, 원본 객체와 동일한 인터페이스를 통해 상호작용합니다.

Spring 컨테이너는 프록시를 빈으로 등록하며, @Autowired 시 프록시가 주입됩니다.

결론
Spring AOP는 프록시 패턴을 통해 OCP(개방-폐쇄 원칙)를 준수하며, 코드 중복 없이 횡단 관심사를 효과적으로 관리합니다. JDK/CGLIB 프록시 생성 전략과 런타임 위빙(Runtime Weaving)을 결합해 유연한 AOP 구현을 가능하게 합니다.

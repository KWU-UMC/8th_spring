# 💡 DI (Dependency Injection) - 의존성 주입

### ✅ 정의:

---

- 객체가 직접 의존 객체를 생성하지 않고, 외부에서 주입받는 방식
- 객체 간의 관계를 코드 내부에서 생성하지 않고, 외부 설정 또는 컨테이너가 대신 처리.

### ✅ 왜 필요한가?

---

- 코드의 결합도(Coupling) 감소
- 테스트 용이성 향상 (Mock 객체 주입 가능)
- 객체 간의 책임 분리 → 유지보수 편리

### ✅ 주입 방식 종류

---

### ➡️ 1. **생성자 주입 (Constructor Injection)**

✔️ **설명:**

- 생성자의 파라미터를 통해 의존 객체를 주입
- @Autowired 생략 가능

✅ **장점:**

- 불변성 보장 (final 사용 가능)
- 테스트에 유리 (생성자 인자로 mock 주입 가능)
- 순환 참조 시점에 오류 발생 → 조기 발견 가능
- 필수 의존성을 명확히 표현 가능

⚠️ **단점:**

- 주입 대상이 많으면 생성자 길어짐

  → 그러나 이는 오히려 클래스 책임이 많다는 신호일 수 있음 (SRP 위배)


**🔥 언제 사용하면 좋을까?**

- 가장 권장되는 방식
- 대부분의 경우 생성자 주입 사용 → 정형화된 방식

---

### ➡️ 2. **세터 주입 (Setter Injection)**

✔️ **설명:**

- @Autowired를 이용해 세터 메서드로 주입

✅ **장점:**

- 선택적 의존성 주입에 적합 (필수가 아님)
- 유닛 테스트 시 mock 교체 가능성이 있음

⚠️ **단점:**

- 불변성 보장 안됨
- 의존성 없이 객체가 생성될 수 있음 → Null Pointer Exception 위험
- 런타임 시점까지 누락된 주입 여부를 모름

🔥 **언제 사용하면 좋을까?**

- 특정 기능이 옵션일 때, 또는 초기 설정 이후 수정 가능성이 있을 때

---

### ➡️ 3. **필드 주입 (Field Injection)**

✔️ **설명:**

- 가장 간단한 방식으로, 필드에 직접 @Autowired 사용

**✅ 장점:**

- 코드 간결
- 설정이 빠르고 직관적

**⚠️ 단점:**

- 테스트 어려움 → 필드 접근 제한으로 mock 주입 어려움
- 불변성 없음
- 생성 시 의존성 주입 강제되지 않음 → 설계 취약
- Spring 컨테이너가 없는 환경에서는 주입 불가능

🔥 **언제 사용하면 좋을까?**

- 아주 단순한 데모/프로토타입 개발 시
- 실무에서는 비권장 (특히 테스트 가능성이 있는 경우)

### 📊 비교 요약

| 방식 | 불변성 | 테스트 용이성 | 필수 의존성 표현 | 권장도 |
| --- | --- | --- | --- | --- |
| 생성자 주입 | ✅ 높음 | ✅ 좋음 | ✅ 가능 | ⭐⭐⭐⭐⭐ |
| 세터 주입 | ❌ 낮음 | ✅ 보통 | ❌ 불가능 | ⭐⭐ |
| 필드 주입 | ❌ 없음 | ❌ 어려움 | ❌ 불가능 | ⭐ |

# 💡 IoC (Inversion Of Control) - 제어의 역전

### ✅ 정의:

---

- 객체의 생성, 의존성 주입, 생명주기 관리 등 객체 제어권을 개발자가 아닌 프레임워크에 위임하는 개념
- 즉, 애플리케이션 전반의 컴포넌트(객체) 관리 흐름이 역전되었다는 것을 의미함

### 🔍 핵심 요소

---

1. **객체의 생성**: 개발자가 new로 직접 생성하지 않음 → Spring이 관리
2. **의존관계 설정**: 어떤 객체가 무엇을 필요로 하는지 스프링이 파악하고 주입
3. **설정(Configuration)**: XML, Java Config, 어노테이션 등을 통해 객체 간 관계를 정의
4. **생명주기 관리**: Bean의 생성 → 초기화 → 소멸까지 프레임워크가 자동 처리

### ➡️ IoC Container

---

**✅ 역할:**

- 객체(Bean)를 생성하고, 의존성을 주입하며, 라이프사이클을 관리하는 스프링의 핵심 컴포넌트.

**✅ 종류:**

| 컨테이너 | 설명 |
  | --- | --- |
| **BeanFactory** | 가장 기본적인 IoC 컨테이너 (지연 로딩) |
| **ApplicationContext** | BeanFactory 확장판, 주로 사용하는 컨테이너 (즉시 로딩 + 다양한 기능) |

# 💡 프레임워크와 API의 차이

### 📌 프레임워크(Framework):

- 개발자가 따르는 일종의 개발 틀(Template) 또는 뼈대
- 소프트웨어의 기본 구조와 흐름을 제어하고 제공함
- 개발자는 정해진 규칙 내에서 필요한 기능을 구현함
- 대표 예시: Spring Framework, Django, Angular 등

### 🧩 특징:

- IoC(Inversion of Control)

  → 개발자가 코드를 호출하는 것이 아니라, 프레임워크가 개발자의 코드를 호출

- 재사용 가능한 구조 제공
- 생산성 향상 + 아키텍처 통일성

---

### 📌 API(Application Programming Interface):

- 소프트웨어가 다른 소프트웨어와 상호작용하기 위해 제공하는 명령/기능의 집합
- 특정 기능을 쉽게 사용할 수 있도록 만든 인터페이스
- 프레임워크보다 훨씬 작은 단위에서 동작

### 🧩 특징:

- 구현된 기능을 가져다 쓰는 도구
- 직접 흐름을 제어하지 않음
- 대표 예시: Java의 List, HttpClient, Google Map API, Twitter API 등

---

### ⚖️ 프레임워크 vs API 비교

| 항목 | 프레임워크 (Framework) | API (Application Programming Interface) |
  | --- | --- | --- |
| 제어 흐름 | 프레임워크가 제어권을 가짐 (IoC) | 개발자가 직접 호출 (제어권 없음) |
| 역할 | 구조와 설계 방식까지 제공 | 기능(기능 집합)을 외부에 노출 |
| 개발 방식 | 정해진 방식에 따라 개발 | 원하는 곳에서 자유롭게 호출 |
| 예시 | Spring, React, Flask | Java API, Kakao 로그인 API, ChatGPT API 등 |

# 💡 AOP (Aspect Oriented Programming) - 관점 지향 프로그래밍

### ✅ 정의:

---

AOP(Aspect Oriented Programming)는 공통적으로 사용되는 기능(공통 관심사, cross-cutting concern)을 핵심 비즈니스 로직과 분리하여 모듈화할 수 있도록 도와주는 프로그래밍 패러다임


### 🧩 AOP가 필요한 이유

---

- 하나의 애플리케이션에는 여러 컴포넌트가 공통적으로 수행하는 작업들이 존재한다.
- 예:
    - 로깅
    - 트랜잭션 처리
    - 보안 검사
    - 성능 측정

이런 공통 기능을 매번 비즈니스 로직마다 직접 작성하면 코드 중복, 유지보수 어려움 발생

AOP는 이를 중앙에서 한 번만 정의하고, 자동으로 끼워 넣는 구조를 제공한다.

### 🔧 핵심 용어 정리

---

| 용어 | 설명 |
  | --- | --- |
| **Aspect** | 공통 기능을 정의한 모듈 (예: 로깅 기능) |
| **JoinPoint** | 공통 기능이 끼어들 수 있는 지점 (메서드 실행 등) |
| **Advice** | 실제 실행될 공통 기능 코드 (Before, After 등) |
| **Pointcut** | Advice가 적용될 JoinPoint를 선정하는 기준 |
| **Weaving** | Aspect를 실제 코드에 적용하는 과정 (런타임, 컴파일타임 등) |

### ✅ AOP의 장점

---

- ✨ **관심사 분리(Separation of Concerns)**

  → 핵심 로직과 부가 로직(공통 기능)을 분리

- 🧼 **코드 중복 감소**

  → 로깅/보안/트랜잭션 등의 반복 코드를 제거

- 🔍 **유지보수성 향상**

  → 공통 로직 수정 시 하나만 수정하면 전체 반영됨

- 🧪 **테스트 용이**

  → 핵심 비즈니스 로직이 깔끔해지고 단위 테스트 수월해짐


### ⚠️ AOP의 단점

---

- 초기 학습 난이도 어려움 (특히 개념/용어)
- 디버깅 어려움 (자동으로 삽입되는 코드 흐름)
- 과도하게 사용 시 오히려 코드 흐름 파악이 어려워질 수 있음
# 💡 서블릿

### ✅ 정의:

---

- Java 언어로 작성된 웹 요청/응답 처리용 서버 프로그램
- 클라이언트의 요청(HTTP Request)을 받아 처리하고, 그 결과(HTTP Response)를 반환하는 자바 기반의 웹 컴포넌트


### 🧩 서블릿의 주요 역할

---

- 웹 브라우저로부터 HTTP 요청 수신
- 요청에 대한 비즈니스 로직 처리
- 처리 결과를 HTTP 응답 형태로 반환

### ⚙️ 서블릿의 동작 흐름

---


> 브라우저 요청 → 웹 서버 → 서블릿 컨테이너(Tomcat) → 서블릿 객체 호출 → 응답 반환


**서블릿 생명주기 (Lifecycle)**

1. **init()** – 서블릿 초기화 (한 번만 호출됨)
2. **service()** – 클라이언트 요청 처리 (매 요청마다 실행)
3. **destroy()** – 서블릿 종료 전 정리 작업

### ✅ 서블릿의 특징

---

| 항목 | 설명 |
| --- | --- |
| **Java 기반** | 순수 자바로 동작하는 웹 기술 |
| **서블릿 컨테이너 필요** | Tomcat, Jetty 등 웹 컨테이너가 서블릿 실행 |
| **HTTP 지원** | HttpServlet 기반으로 요청/응답 처리 |

### ✅ 서블릿의 장점

---

- 표준 자바 API 기반
- HTTP 요청과 응답을 직접 제어 가능
- 모든 Java 웹 기술의 기초

### ⚠️ 서블릿의 단점

---

- HTML과 Java 코드가 뒤섞임 → 유지보수 어려움
- 복잡한 로직 분리 어려움 (MVC 패턴 없음)
- 개발 생산성이 낮음